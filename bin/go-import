#!/usr/bin/env ruby

require "thor"
require "go_import"

RUNNER_DIR = ".go_import"

class GoImportCommandLine < Thor

    desc "about", "About go-import"
    def about()
        puts "go-import is an import tool for LIME Go. It can take virtually any input source and create pretty looking xml-files that LIME Go likes. go-import has some predefined sources that will make it easy for you to migrate your data."
        puts ""
    end

    desc "list-sources", "Lists the available sources"
    def list_sources()
        puts "The following sources are available:"
        puts

        sources = GoImport::Sources.new(source_path)
        sources.list().each do |s|
            puts "\t#{s}"
        end

        puts "\nCreate a new project with 'go-import new' with one of these sources."
    end

    desc "new", "Creates a new migration project with a specifed name and source"
    option(:project,
           :desc => "Name of the project. The project will be created in a folder with the same name.",
           :type => :string,
           :required => true)
    option(:source,
           :desc => "Name of the source to use. Use list-sources to show available sources.",
           :type => :string,
           :required => true)
    def new(project = nil, source = nil)
        sources = GoImport::Sources.new(source_path)

        if sources.create_project_from_source(options.project, options.source)
            puts "\nProject '#{options.project}' created from source '#{options.source}'."
            puts "Modify the #{options.project}/converter.rb script to suit your source."
            puts "Use 'go-import run' from the project directory to create the xml file for LIME Go."
        end
    end

    desc "run-with-files", "Executes the current project and create a go.zip file with data and files. Existing go.zip will be overwritten, use --output to specify a different filename."
    option(:output,
           :desc => "Name of the file where the converted source will be saved. This file should be sent to LIME Go. If the file already exist it will be replaced.",
           :type => :string,
           :required => false)
    option(:files_folder,
           :desc => "Name of the folder where current files are stored. This is the folder where documents are stored. Default is 'files'",
           :type => :string,
           :required => false)
    def run_import_with_files()
        if !is_valid_goimport_project?
            return
        end

        runner_file = File.expand_path("./#{RUNNER_DIR}/runner.rb", Dir.pwd)
        require(runner_file)
        model = convert_source()

        is_ok, error_msg = can_be_serialized?(model)
        if is_ok
            go_data_zip = options.output.nil? == true ? "go.zip" : options.output
            files_folder = options.files_folder.nil? == true ? "files" : options.files_folder
            model.save_to_zip(go_data_zip, files_folder)
            puts "Source has been been converted into '#{go_data_zip}'."
        else
            puts "Source could not be converted due to"
            puts error_msg
        end
    end

    desc "run", "Executes the current project and create a go.xml file. Existing go.xml will be overwritten, use --output to specify a different filename"
    option(:output,
           :desc => "Name of the file where the converted source will be saved. This file should be sent to LIME Go. If the file already exist it will be replaced.",
           :type => :string,
           :required => false)
    def run_import()
        # run is a Thor reserved word and cant be used as a method name

        if !is_valid_goimport_project?()
            return
        end

        runner_file = File.expand_path("./#{RUNNER_DIR}/runner.rb", Dir.pwd)
        require(runner_file)

        # the source must implement the convert_source method that
        # returns an instance of GoImport::RootModel
        model = convert_source()

        is_ok, error_msg = can_be_serialized?(model)
        if is_ok
            go_data_filename = options.output.nil? == true ? "go.xml" : options.output
            model.serialize_to_file(go_data_filename)
            puts "Source has been been converted into '#{go_data_filename}'."
        else
            puts "Source could not be converted due to"
            puts error_msg
        end
    end

    private
    def can_be_serialized?(rootmodel)
        is_ok = false
        error = rootmodel.sanity_check
        if error.empty?
            error = rootmodel.validate

            if error.empty?
                is_ok = true
            end
        end

        return [is_ok, error]
    end


    private
    def is_valid_goimport_project?()
        puts "looking for #{RUNNER_DIR}"
        if Dir.exists?(RUNNER_DIR) == false
            puts "This doesnt look like a go-import project. Are you in the right directory or did you mess with the '#{RUNNER_DIR}' folder?"
            return false
        end

        puts "looking for file"
        runner_file = File.expand_path("./#{RUNNER_DIR}/runner.rb", Dir.pwd)
        puts "filename: #{runner_file}"
        if File.exists?(runner_file) == false
            puts "I can't run this project. Did you mess with the '#{RUNNER_DIR}' folder?"
            return false
        end

        puts "This is a valid goimport project"
        return true
    end

    private
    def source_path()
        File.expand_path("../sources", File.dirname(__FILE__))
    end
end

GoImportCommandLine.start(ARGV)

